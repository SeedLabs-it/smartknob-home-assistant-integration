{"version":3,"file":"readableStream.browser.js","sources":["../src/internal.ts","../src/readableStream.ts"],"sourcesContent":["import type { InlineOptions } from '@twind/core'\nimport { tw as tw$, identity, consume, stringify, noop } from '@twind/core'\n\nimport diff from 'fast-diff'\n\nexport function createState(options: InlineOptions['tw'] | InlineOptions = {}) {\n  const { tw = tw$, minify = identity } =\n    typeof options == 'function' ? ({ tw: options } as InlineOptions) : options\n\n  let buffer = ''\n  let lastStyle: string | null = null\n  let restoreCurrentState = noop\n\n  return {\n    push: (chunk: string): boolean => {\n      buffer += chunk\n      return lastStyle === null ? isShellReady(buffer) : isSuspenseChunkReady(buffer)\n    },\n\n    flush: (): string | undefined => {\n      if (buffer) {\n        const restore = tw.snapshot()\n\n        restoreCurrentState()\n\n        let html = consume(buffer, tw)\n        const nextStyle = minify(stringify(tw.target), html)\n\n        restoreCurrentState = tw.snapshot()\n\n        restore()\n\n        if (lastStyle === null) {\n          // inital shell is ready\n          html = html.replace('</head>', `<style data-twind>${nextStyle}</style></head>`)\n        } else {\n          // a suspense chunk\n          const styleDiff: [offset: number, text: string][] = []\n\n          let offset = 0\n          for (const [type, text] of diff(lastStyle, nextStyle)) {\n            if (type === 1) {\n              // insert\n              styleDiff.push([offset, text])\n            }\n\n            // must be equal: type === 0\n            offset += text.length\n          }\n\n          if (styleDiff.length) {\n            // add style patch script that will update the previously created style element content\n            // but only if client side twind hasn't taken over yet (data-twind=\"claimed\")\n\n            // ;(function (style, diff) {\n            //   if (style) {\n            //     style.textContent = diff.reduce(function (textContent, change) {\n            //       return textContent.slice(0, change[0]) + change[1] + textContent.slice(change[0])\n            //     }, style.textContent || '')\n            //   }\n            // })(document.querySelector('style[data-twind=\"\"]'), [])\n\n            html = `<script>!function(e,n){e&&(e.textContent=n.reduce((function(e,n){return e.slice(0,n[0])+n[1]+e.slice(n[0])}),e.textContent||''))}(document.querySelector('style[data-twind=\"\"]'),${JSON.stringify(\n              styleDiff,\n            )})</script>${html}`\n          }\n        }\n\n        buffer = ''\n        lastStyle = nextStyle\n\n        return html\n      }\n    },\n  }\n}\n\nfunction isShellReady(markup: string): boolean {\n  return markup.endsWith('</body></html>')\n}\n\nfunction isSuspenseChunkReady(markup: string): boolean {\n  return markup.endsWith('</script>')\n}\n","import type { InlineOptions, InlineMinify } from '@twind/core'\n\nimport { createState } from './internal'\n\nexport type { InlineOptions, InlineMinify }\n\nconst encoder = /* #__PURE__ */ new TextEncoder()\nconst decoder = /* #__PURE__ */ new TextDecoder()\n\nexport default class InlineStream extends TransformStream<Uint8Array, Uint8Array> {\n  constructor(options?: InlineOptions['tw'] | InlineOptions) {\n    const state = createState(options)\n\n    const flush: TransformerFlushCallback<Uint8Array> = (controller) => {\n      const markup = state.flush()\n      if (markup) {\n        controller.enqueue(encoder.encode(markup))\n      }\n    }\n\n    super({\n      transform(chunk, controller) {\n        if (state.push(decoder.decode(chunk))) {\n          return flush(controller)\n        }\n      },\n      flush,\n    })\n  }\n}\n"],"names":["consume","stringify","tw","identity","noop","diff","encoder","TextEncoder","decoder","TextDecoder","InlineStream","TransformStream","constructor","options","state","createState","tw$","minify","buffer","lastStyle","restoreCurrentState","push","chunk","markup","endsWith","flush","restore","snapshot","html","nextStyle","target","replace","styleDiff","offset","type","text","length","JSON","controller","enqueue","encode","transform","decode","default"],"mappings":"AAKO,SAAAA,OAAA,EAAAC,SAAA,EAAAC,EAAA,EAAAC,QAAA,EAAAC,IAAA,QAAA,cAAA;AAAA,OAAAC,UAAA,YAAA;ACCP,IAAMC,UAAAA,aAAAA,GAA0B,IAAIC,eAC9BC,UAAAA,aAAAA,GAA0B,IAAIC;AAErB,MAAMC,qBAAqBC;IACxCC,YAAYC,OAA6C,CAAE;QACzD,IAAMC,QAAQC,ADNX,SAAqBF,UAA+C,EAAE,EAAE;YAC7E,IAAM,EAAAX,IAAEA,OAAKc,EAAAA,CAAAA,EAAKC,QAASd,WAAU,GACnC,AAAkB,cAAlB,OAAOU,UAAyB;gBAAEX,IAAIW;YAAQ,IAAsBA,OAAO,EAEzEK,SAAS,IACTC,YAA2B,IAAI,EAC/BC,sBAAsBhB;YAE1B,OAAO;gBACLiB,MAAM,CAACC,QAA2B;2BAChCJ,UAAUI,OACHH,AAAc,IAAI,KAAlBA,YA8DJI,AA9DsCL,OA8D/BM,QAAQ,CAAC,oBAIhBD,AAlEqEL,OAkE9DM,QAAQ,CAAC,YAlE4D;gBACjF;gBAEAC,OAAO,IAA0B;oBAC/B,IAAIP,QAAQ;wBACV,IAAMQ,UAAUxB,KAAGyB,QAAQ;wBAE3BP;wBAEA,IAAIQ,OAAO5B,QAAQkB,QAAQhB,OACrB2B,YAAYZ,OAAOhB,UAAUC,KAAG4B,MAAM,GAAGF;wBAE/CR,sBAAsBlB,KAAGyB,QAAQ;wBAEjCD;wBAEA,IAAIP,AAAc,IAAI,KAAlBA,WAAkB,wBAAA;wBAEpBS,OAAOA,KAAKG,OAAO,CAAC,WAAW,CAAC,kBAAkB,EAAEF,UAAU,eAAe,CAAC;6BACzE;;4BAEL,IAAMG,YAA8C,EAAE,EAElDC,SAAS;4BACb,KAAK,IAAM,CAACC,MAAMC,KAAK,IAAI9B,KAAKc,WAAWU,WAAY;gCACxC,MAATK;gCAEFF,UAAUX,IAAI,CAAC;oCAACY;oCAAQE;iCAAK;;gCAI/BF,UAAUE,KAAKC,MAAM;4BACvB;4BAEIJ,UAAUI,MAAM,IAAA,uFAAA;;;;;;;;;4BAYlBR,CAAAA,OAAO,CAAC,iLAAiL,EAAES,KAAKpC,SAAS,CACvM+B,WACA,UAAU,EAAEJ,KAAK,CAAC,AAAD;wBAEtB,CAAA;+BAEDV,SAAS,IACTC,YAAYU,WAELD;oBACR,CAAA;gBACH;YACF;QACF,EChE8Bf,UAEpBY,QAA8C,CAACa,aAAe;YAClE,IAAMf,SAAST,MAAMW,KAAK;YACtBF,UACFe,WAAWC,OAAO,CAACjC,QAAQkC,MAAM,CAACjB;QAEtC;QAEA,KAAK,CAAC;YACJkB,WAAUnB,KAAK,EAAEgB,UAAU,EAAE;gBAC3B,IAAIxB,MAAMO,IAAI,CAACb,QAAQkC,MAAM,CAACpB,SAC5B,OAAOG,MAAMa;YAEjB;YACAb;QACF;IACF;AACF;SAAAf,gBAAAiC,OAAA"}